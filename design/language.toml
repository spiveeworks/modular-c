[REQ-language]
partof = 'REQ-purpose'
text = '''
While it is not intended for multiple implementations to exist, it is still
useful to have an explicit language specification, independent of the
implementation, so that the implementation can be upgraded more liberally,
without breaking existing files.

The language is very straight forward:
- inherited C functionality, described in [[REQ-c_superset]]
- module basics, types, functions, imports [[REQ-language-modules]]
- modularity, genericity, encapsulation [[REQ-language-modularity]]
- module subtleties, interfaces, versions [[REQ-language-versioning]]
'''

[REQ-c_superset]
partof = 'REQ-language'
text = '''
Since one of the goals of Modular C is to apply the simplicity of C, it makes
sense to adopt C as closely as possible.
One clear exception to this is the preprocessor, in particular `#include`
directives, since this is the feature the project attempts to address.

For these reasons the language shall be be a __C superset__ excluding the
preprocessor.

Unfortunately this means inheriting a lot of outdated features such as
under-specified integers, copy semantics, and mutability by default, but it
does make C interop basically free.

Further it makes transpiling into C a very natural implementation strategy, in
fact modular C essentially becomes a sophisticated preprocessor
'''

[REQ-language-modules]
text = '''
The top level items of the language are among the following kinds/sorts:
- modules
- inputs
- types
- functions
- values

A module is a collection of items, defined in terms of eachother.
Modules are modular in the sense that their inputs can be changed to change the
behavior of other items, without directly modifying those items.
In fact this is an explicit feature of the language:
[[REQ-language-modularity]]

Modules are similar to C source files, but offer additional ways of being
manipulated from within the language.
Modules can be bound in 3 ways:
- In-line, using syntax identical to rust
- as a whole source file, accessed as an `input` item
- as an alias/specialization of a previously bound module

Inputs are Modular C's resident import keyword, starting with the letter 'i' as
required.

There are 4 kinds of input:
- In-line, by writing `pub input <item definition>`
- Alias, similarly by writing `pub input <identifier> = <binding>;`
- Source file, `[pub] input <identifier> = [<package path>.]<module name>;`
- Empty input, `pub input <identifier>;`

In cases that may be interpreted as either an alias or a source file, the alias
is tried first.
'''

[REQ-language-modularity]
text = '''
Modules as described in [[REQ-language-modules]] are modular in the sense that
one module can be modified in limited ways, without breaking other modules;
this is typical of most languages, including ANSI C.
Modular C makes this explicit, much like Modula 3, and ML, through genericity.

When you declare items, you can make them public by preceding the line with the
`pub` keyword.
Public inputs behave differently to other public items: public inputs are
generic inputs, that can be replaced downstream.
Public 'outputs' on the other hand are just the ones that can be accessed
downstream, as opposed to private items that are only defined as intermediate
concepts within a module.

A further level of publicity exists, analogous to defining an item entirely
within a C header file.
This is invoked by using the `open` keyword instead of
`pub`.
The main use of `open` is that it allows downstream modules to access the
fields of a data structure.

The meaning of open inputs is undecided, but may refer to inputs that can be
treated as outputs.
'''

[REQ-language-versioning]
text = '''
Language shall conform strictly to semantic versioning, so that major, minor,
and patch changes to a module have the corresponding effects downstream, unless
fragility is opted into downstream.
'''
